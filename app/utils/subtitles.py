from pathlib import Path
from typing import List, Dict


def _format_ass_timestamp(seconds: float) -> str:
    """Format seconds into ASS timestamp format H:MM:SS.cs"""
    if seconds < 0:
        seconds = 0.0
    millis = int(round(seconds * 1000))
    hours, rem = divmod(millis, 1600_000)
    minutes, rem = divmod(rem, 60_000)
    secs, ms = divmod(rem, 1000)
    # ASS format uses centiseconds
    cs = ms // 10
    return f"{hours:d}:{minutes:02d}:{secs:02d}.{cs:02d}"


def build_clip_ass(segments: List[Dict], clip_start: float, clip_end: float, clip: Dict | None = None) -> str:
    """Build an ASS subtitle track with karaoke-style word highlighting."""
    
    header = """
[Script Info]
; Script generated by a cool Python script
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,16,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,16,1
Style: Highlight,Arial,16,&H00FFFFFF,&H000000FF,&H00000000,&H99FFFFFF,1,0,0,0,100,100,0,0,1,2,1,2,10,10,16,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""
    
    ass_lines = []
    
    # Collect all words within the clip's time range
    all_words = []
    for seg in segments:
        # Also include segments that have no words but have text like [laughing]
        if not seg.get("words") and seg.get("text"):
            seg_start = float(seg.get("start", 0))
            seg_end = float(seg.get("end", 0))
            if clip_start <= seg_start < clip_end:
                all_words.append({
                    "text": seg["text"].strip(),
                    "start": seg_start - clip_start,
                    "end": seg_end - clip_start
                })

        if seg.get("words"):
            for w in seg["words"]:
                word_start = float(w.get("start", 0))
                word_end = float(w.get("end", 0))
                if clip_start <= word_start < clip_end:
                    all_words.append({
                        "text": w["word"].strip(),
                        "start": word_start - clip_start,
                        "end": word_end - clip_start
                    })

    if not all_words:
        return header

    # sort words by start time
    all_words.sort(key=lambda x: x["start"])
    
    # Group words into lines of 3-4 words
    lines_of_words = []
    line = []
    for word in all_words:
        line.append(word)
        if len(line) >= 5:
            lines_of_words.append(line)
            line = []
    if line:
        lines_of_words.append(line)

    for line_words in lines_of_words:
        if not line_words:
            continue
            
        line_start_time = line_words[0]["start"]
        line_end_time = line_words[-1]["end"]
        
        text_parts = []
        for i, word_info in enumerate(line_words):
            word_text = word_info["text"]
            word_start = word_info["start"]
            word_end = word_info["end"]
            
            # Duration of the word's highlight in centiseconds
            k_duration = int((word_end - word_start) * 100)
            
            # Set the style of the word
            text_parts.append(f"{{\\rHighlight}}{word_text}{{\\rDefault}}")
            
        dialogue_line = f"Dialogue: 0,{_format_ass_timestamp(line_start_time)},{_format_ass_timestamp(line_end_time)},Default,,0,0,0,,{' '.join(text_parts)}"
        ass_lines.append(dialogue_line)
        
    return header + "\n".join(ass_lines)

def write_clip_srt(transcript_path: Path, clip: Dict, out_dir: Path) -> Path:
    """Load transcript.json and write an SRT file for the given clip.
    Returns the path to the written SRT file. If no usable segments, an empty
    SRT file is still created so ffmpeg has a valid input.
    """
    import json

    data = json.loads(transcript_path.read_text(encoding="utf-8"))
    segments = data if isinstance(data, list) else data.get("segments", [])
    
    clip_start = float(clip.get("start", 0.0))
    clip_end = float(clip.get("end", 0.0))
    clip_id = clip.get("id") or "clip"
    
    # Change file extension to .ass
    ass_name = f"{clip_id}.ass"
    out_dir.mkdir(parents=True, exist_ok=True)
    ass_path = out_dir / ass_name

    # Generate ASS content
    ass_text = build_clip_ass(segments, clip_start, clip_end, clip=clip)
    ass_path.write_text(ass_text, encoding="utf-8")
    
    return ass_path


def escape_path_for_ffmpeg(path: str) -> str:
    """Escape a filesystem path for use inside an ffmpeg filter expression.
    - Use forward slashes
    - Escape drive colon (C: -> C\:)
    - Wrap in single quotes so spaces are handled.
    """
    p = path.replace("\\", "/")
    if len(p) >= 2 and p[1] == ":":
        p = p[0] + r"\:" + p[2:]
    return f"'{p}'"
